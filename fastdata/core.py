# AUTOGENERATED! DO NOT EDIT! File to edit: 00_core.ipynb (unless otherwise specified).

__all__ = ['FastDataDataframeUtilities', 'FastDataSeriesUtilities', 'extract_number_from_string', 'bin_column',
           'fill_empty']

# Cell
import pandas as pd
import numpy as np
import re
from fastcore.all import *

# Cell
@pd.api.extensions.register_dataframe_accessor('fdt')
class FastDataDataframeUtilities:
    def __init__(self, pandas_obj):
        self._obj = pandas_obj

    def flatten_multiindex(self,axis='all'):
        df = self._obj.copy()
        if 'MultiIndex' in str(type(df.columns)) and axis in ('all', 'columns'):
            df.columns = df.columns.map(lambda x: '_'.join([str(i) for i in x]))
        if (('MultiIndex' in str(type(df.index))) or (df.index.name != None )) and axis in ('all', 'index'):
            df = df.reset_index()
        return df

# Cell
@pd.api.extensions.register_series_accessor('fdt')
class FastDataSeriesUtilities:
    def __init__(self, pandas_obj):
        self._obj = pandas_obj

    def find_between_text(self, start_string, end_string):
        series = self._obj
        search_expr = start_string + '(.*)' + end_string
        series = series.str.extract(search_expr)
        return series

# Cell
@patch_to(FastDataSeriesUtilities)
def extract_number_from_string(self, dtype):
    series = self._obj
    series = series.str.extract('(\d+)')
    series = series.astype(dtype)
    return series

# Cell
@patch_to(FastDataSeriesUtilities)
def bin_column(self, **kwargs):
    series = self._obj
    #Parameters
    p = kwargs
    if p['mode'] == 'size':
        interval_range = pd.interval_range(start=p['start'], freq=p['size'], end=p['end'])
        #print(interval_range)
        series = pd.cut(series, bins=interval_range)
        return series

    if p['mode'] == 'number':
        series = pd.cut(series, bins=p['bin_number'])
        return series

    if p['mode'] == 'quantiles':
        series = pd.qcut(series, q=p['quantiles'])
        return series

    if p['mode'] == 'custom':
        interval_range=pd.IntervalIndex.from_breaks(p['breaks'], closed=p['closed'])
        series = pd.cut(series, bins= interval_range)
        return series

# Cell
@patch_to(FastDataSeriesUtilities)
def fill_empty(self, **kwargs):
    series = self._obj
    p = kwargs
    if p['mode'] == 'function':
        if p['function'] == 'ffill':
            series = series.fillna(method='ffill')
        elif p['function'] == 'bfill':
            series = series.fillna(method='bfill')
        elif p['function'] == 'mean':
            series = series.fillna(series.mean())
        elif p['function'] == 'most_frequent':
            series = series.fillna(series.mode()[0])
    elif p['mode'] == 'value':
        series = series.fillna(p['value'])

    return series